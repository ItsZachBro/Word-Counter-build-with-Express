"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.chordVoicings = exports.notePitches = exports.isNotePitch = void 0;
const interval_1 = require("../interval");
const note_1 = require("../note");
const utils_1 = require("../utils");
const key_1 = require("../key");
const NOTE_PITCHES = [0, 1, 2, 3, 4, 5, 6, 7, 8];
function isNotePitch(notePitch) {
    return NOTE_PITCHES.includes(notePitch);
}
exports.isNotePitch = isNotePitch;
exports.notePitches = [...NOTE_PITCHES];
function isValidVoicedNote(note, pitch) {
    if ([0, 1].includes(pitch) && !['A', 'A#', 'Bb', 'B'].includes(note)) {
        return false;
    }
    else if (pitch === 8 && note !== 'C') {
        return false;
    }
    else if (!isNotePitch(pitch)) {
        return false;
    }
    else if (!(0, note_1.isNote)(note)) {
        return false;
    }
    else {
        return true;
    }
}
function voiceAllNotes(notes, voicingOptions) {
    // We can generate pitches by comparing distance to C, since C is the start of a given pitch.
    // If notes get farther from C, we're in the same pitch. If they suddenly get closer, we're in the next pitch.
    const distanceToCByNaturalNote = {
        C: 0,
        D: 1,
        E: 2,
        F: 3,
        G: 4,
        A: 5,
        B: 6,
    };
    let currentDistanceToC = 0;
    let previousDistanceToC = distanceToCByNaturalNote[(0, note_1.getNaturalNoteRoot)(notes[0])];
    let pitchOffset = 0;
    let totalToneSpread = 0;
    const voicedNotes = [{ pitch: voicingOptions.startingPitch, note: notes[0] }];
    do {
        const index = voicedNotes.length;
        const currentNote = notes[(index - 1) % notes.length];
        const nextNote = notes[index % notes.length];
        const nextIntervalLength = (0, interval_1.getIntervalBetweenNotes)(currentNote, nextNote).length;
        if (totalToneSpread + nextIntervalLength > voicingOptions.maxSpread) {
            console.log(`Adding additional chord note ${nextNote} will result in a chord with spread greater than ${voicingOptions.maxSpread}.`);
            break;
        }
        totalToneSpread += nextIntervalLength;
        currentDistanceToC = distanceToCByNaturalNote[(0, note_1.getNaturalNoteRoot)(nextNote)];
        if (currentDistanceToC <= previousDistanceToC) {
            pitchOffset += 1;
        }
        const pitch = voicingOptions.startingPitch + pitchOffset;
        previousDistanceToC = currentDistanceToC;
        if (!isValidVoicedNote(nextNote, pitch)) {
            console.log(`Adding additional chord note ${nextNote}${pitch} results in an invalid voiced note`);
            continue;
        }
        voicedNotes.push({
            pitch: pitch,
            note: nextNote
        });
    } while (totalToneSpread < voicingOptions.maxSpread);
    return voicedNotes;
}
function calculateTension(voicedNotes) {
    let tension = 0;
    let density = 0;
    for (let i = 0; i < voicedNotes.length - 1; i++) {
        density += getDistanceBetweenVoicedNotes(voicedNotes[i], voicedNotes[i]);
        for (let j = i + 1; j < voicedNotes.length; j++) {
            const interval = (0, interval_1.getIntervalBetweenNotes)(voicedNotes[i].note, voicedNotes[j].note);
            tension += interval.tension;
        }
    }
    // TODO: Decide how we actually want to calculate tension. Tension per note is... fine
    return tension / voicedNotes.length;
}
function getDistanceBetweenVoicedNotes(firstVoicedNote, secondVoicedNote) {
    const interval = (0, interval_1.getIntervalBetweenNotes)(firstVoicedNote.note, secondVoicedNote.note);
    return interval.length + (12 * (secondVoicedNote.pitch - firstVoicedNote.pitch));
}
function chordVoicings(chord, voicingOptions) {
    const voicedNotes = voiceAllNotes(chord.notes, voicingOptions);
    const voicedIntervals = voicedNotes.map(voicedNote => (0, interval_1.interval)(chord.intervals[chord.notes.findIndex(note => note === voicedNote.note)]));
    const voicedNoteCombinations = [];
    if ((voicingOptions.minSize && voicingOptions.maxSize) && voicingOptions.minSize <= voicingOptions.maxSize) {
        for (let i = voicingOptions.minSize; i <= voicingOptions.maxSize; i++) {
            (0, utils_1.generateOrderedCombinations)(voicedNotes, voicedNoteCombinations, i);
        }
    }
    else {
        console.error(`Cannot generate a chord with max size ${voicingOptions.maxSize} and min size ${voicingOptions.minSize}.`);
        return [];
    }
    const chordNotesByDegree = (0, key_1.key)(chord.root, 'Ionian').noteByDegree;
    let omitNotes = [];
    if (voicingOptions.omitNotes) {
        omitNotes = omitNotes.concat(voicingOptions.omitNotes);
    }
    if (voicingOptions.omitDegrees) {
        omitNotes = omitNotes.concat(voicingOptions.omitDegrees.map(degree => chordNotesByDegree[degree]));
    }
    let guaranteeNotes = [];
    if (voicingOptions.guaranteeNotes) {
        guaranteeNotes = guaranteeNotes.concat(voicingOptions.guaranteeNotes);
    }
    if (voicingOptions.guaranteeDegrees) {
        guaranteeNotes = guaranteeNotes.concat(voicingOptions.guaranteeDegrees.map(degree => chordNotesByDegree[degree]));
    }
    const filteredVoicedNoteCombinations = voicedNoteCombinations.filter(combination => {
        if (voicingOptions.enforceSlash && combination[0].note !== chord.slashNote) {
            return false;
        }
        const combinationNotes = combination.map(voicedNote => voicedNote.note);
        if (omitNotes.length && combination.some(voicedNote => omitNotes.includes(voicedNote.note))) {
            return false;
        }
        if (guaranteeNotes.length && !guaranteeNotes.every(note => combinationNotes.includes(note))) {
            return false;
        }
        return true;
    });
    // TODO: Rank tension and density
    const dedupedVoicedNoteCombinations = (0, utils_1.removeDuplicates)(filteredVoicedNoteCombinations);
    const chordVoicings = [];
    dedupedVoicedNoteCombinations.forEach(voicedNoteCombination => {
        chordVoicings.push({
            chord: chord,
            voicingOptions: voicingOptions,
            voicedNotes: voicedNoteCombination,
            tension: calculateTension(voicedNoteCombination)
        });
    });
    return chordVoicings;
}
exports.chordVoicings = chordVoicings;
