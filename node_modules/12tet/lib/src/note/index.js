"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enharmonicEquivalents = exports.tonesByNote = exports.tones = exports.getNextNaturalNote = exports.getNaturalNoteRoot = exports.noteRegisters = exports.isNoteRegister = exports.notes = exports.isNote = exports.theoreticalNotes = exports.isTheoreticalNote = exports.theoreticalFlatNotes = exports.isTheoreticalFlatNote = exports.theoreticalSharpNotes = exports.isTheoreticalSharpNote = exports.standardNotes = exports.isStandardNote = exports.standardAccentedNotes = exports.isStandardAccentedNote = exports.standardFlatNotes = exports.isStandardFlatNote = exports.standardSharpNotes = exports.isStandardSharpNote = exports.naturalNotes = exports.isNaturalNote = void 0;
const utils_1 = require("../utils");
const NATURAL_NOTES = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
function isNaturalNote(note) {
    return NATURAL_NOTES.includes(note);
}
exports.isNaturalNote = isNaturalNote;
exports.naturalNotes = [...NATURAL_NOTES];
const STANDARD_SHARP_NOTES = ['F#', 'C#', 'G#', 'D#', 'A#', 'E#', 'B#'];
function isStandardSharpNote(note) {
    return STANDARD_SHARP_NOTES.includes(note);
}
exports.isStandardSharpNote = isStandardSharpNote;
exports.standardSharpNotes = [...STANDARD_SHARP_NOTES];
const STANDARD_FLAT_NOTES = ['Bb', 'Eb', 'Ab', 'Db', 'Gb', 'Cb', 'Fb'];
function isStandardFlatNote(note) {
    return STANDARD_FLAT_NOTES.includes(note);
}
exports.isStandardFlatNote = isStandardFlatNote;
exports.standardFlatNotes = [...STANDARD_FLAT_NOTES];
const STANDARD_ACCENTED_NOTES = [...STANDARD_SHARP_NOTES, ...STANDARD_FLAT_NOTES];
function isStandardAccentedNote(note) {
    return STANDARD_ACCENTED_NOTES.includes(note);
}
exports.isStandardAccentedNote = isStandardAccentedNote;
exports.standardAccentedNotes = [...STANDARD_ACCENTED_NOTES];
const STANDARD_NOTES = [...NATURAL_NOTES, ...STANDARD_SHARP_NOTES, ...STANDARD_FLAT_NOTES];
function isStandardNote(note) {
    return STANDARD_NOTES.includes(note);
}
exports.isStandardNote = isStandardNote;
exports.standardNotes = (0, utils_1.removeDuplicates)([...STANDARD_NOTES]);
const THEORETICAL_SHARP_NOTES = ['C##', 'D##', 'E##', 'F##', 'G##', 'A##', 'B##'];
function isTheoreticalSharpNote(note) {
    return THEORETICAL_SHARP_NOTES.includes(note);
}
exports.isTheoreticalSharpNote = isTheoreticalSharpNote;
exports.theoreticalSharpNotes = [...THEORETICAL_SHARP_NOTES];
const THEORETICAL_FLAT_NOTES = ['Cbb', 'Dbb', 'Ebb', 'Fbb', 'Gbb', 'Abb', 'Bbb'];
function isTheoreticalFlatNote(note) {
    return THEORETICAL_FLAT_NOTES.includes(note);
}
exports.isTheoreticalFlatNote = isTheoreticalFlatNote;
exports.theoreticalFlatNotes = [...THEORETICAL_FLAT_NOTES];
const THEORETICAL_NOTES = [...THEORETICAL_SHARP_NOTES, ...THEORETICAL_FLAT_NOTES];
function isTheoreticalNote(note) {
    return THEORETICAL_NOTES.includes(note);
}
exports.isTheoreticalNote = isTheoreticalNote;
exports.theoreticalNotes = (0, utils_1.removeDuplicates)([...THEORETICAL_NOTES]);
const NOTES = [...STANDARD_NOTES, ...THEORETICAL_NOTES];
function isNote(note) {
    return NOTES.includes(note);
}
exports.isNote = isNote;
exports.notes = (0, utils_1.removeDuplicates)([...NOTES]);
const NOTE_REGISTER = [0, 1, 2, 3, 4, 5, 6, 7, 8];
function isNoteRegister(register) {
    return NOTE_REGISTER.includes(register);
}
exports.isNoteRegister = isNoteRegister;
exports.noteRegisters = [...NOTE_REGISTER];
function getNaturalNoteRoot(note) {
    return note[0];
}
exports.getNaturalNoteRoot = getNaturalNoteRoot;
// Given a note, return the next natural note - i.e. B# => C, Cbb => D
function getNextNaturalNote(note) {
    for (let i = 0; i < NATURAL_NOTES.length; i++) {
        if (NATURAL_NOTES[i] === note[0]) {
            return (0, utils_1.getWrappedArrayElement)([...NATURAL_NOTES], i + 1);
        }
    }
    throw TypeError(`Could not find next natural note for note ${note}`);
}
exports.getNextNaturalNote = getNextNaturalNote;
// All 12 tones in order
exports.tones = [
    ['B#', 'C', 'Dbb'],
    ['B##', 'C#', 'Db'],
    ['C##', 'D', 'Ebb'],
    ['D#', 'Eb', 'Fbb'],
    ['D##', 'E', 'Fb'],
    ['E#', 'F', 'Gbb'],
    ['E##', 'F#', 'Gb'],
    ['F##', 'G', 'Abb'],
    ['G#', 'Ab'],
    ['G##', 'A', 'Bbb'],
    ['A#', 'Bb', 'Cbb'],
    ['A##', 'B', 'Cb']
];
// A record mapping each note to its tone and its tones relative position
function getTonesByNote() {
    const tonesByNote = {};
    exports.tones.forEach((tone, index) => {
        tone.forEach(note => {
            tonesByNote[note] = { tone, index };
        });
    });
    return tonesByNote;
}
exports.tonesByNote = getTonesByNote();
function enharmonicEquivalents(note) {
    const tone = exports.tonesByNote[note].tone;
    const noteIndex = tone.indexOf(note);
    if (noteIndex !== -1) {
        return (0, utils_1.removeArrayElement)(tone, noteIndex);
    }
    else {
        return tone; // This should never happen
    }
}
exports.enharmonicEquivalents = enharmonicEquivalents;
